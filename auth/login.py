from fastapi import APIRouter, HTTPException, Body
from pydantic import BaseModel
from helpers.password_helpers import check_password
from helpers.logger import logger
# Placeholder imports - we'll need these later
# from helpers.mongo_manager import MongoManager
# from fastapi import Depends
# from jose import jwt, JWTError
# from datetime import datetime, timedelta
# from config import Config

auth_router = APIRouter()

# Placeholder: DB should be injected via Depends
# database = MongoManager(config=Config()).get_db()

class UserLogin(BaseModel):
    username: str
    password: str

@auth_router.post("/login")
async def login(user_credentials: UserLogin = Body(...)):
    """
    Authenticate user with username and password from request body.
    Returns a JWT token upon successful authentication.
    """
    # Placeholder: Replace with actual DB access via Depends
    # Example: user = await database.users.find_one({"username": user_credentials.username})
    # For now, let's assume we have a user object for demonstration
    # In a real app, fetch this from DB using dependency injection
    mock_user_db = {
        "testuser": {
            "username": "testuser",
            # Example hash generated by the new hash_password function
            "password": "$argon2id$v=19$m=65536,t=3,p=4$abcdefghijklmnop$qrstuvwxyzABCDEF",
            "email": "test@example.com",
            "full_name": "Test User"
        }
    }
    user = mock_user_db.get(user_credentials.username)

    if not user:
        logger.warning(f"Login attempt failed for non-existent user: {user_credentials.username}")
        raise HTTPException(status_code=401, detail="Invalid username or password")

    hashed_password = user.get("password")
    if not hashed_password or not check_password(user_credentials.password, hashed_password):
        logger.warning(f"Login attempt failed for user: {user_credentials.username} (incorrect password)")
        raise HTTPException(status_code=401, detail="Invalid username or password")

    logger.info(f"User '{user_credentials.username}' successfully authenticated.")

    # Placeholder: Generate JWT token here
    # access_token_expires = timedelta(minutes=Config.ACCESS_TOKEN_EXPIRE_MINUTES)
    # to_encode = {"sub": user.get("username"), "exp": datetime.utcnow() + access_token_expires}
    # encoded_jwt = jwt.encode(to_encode, Config.SECRET_KEY, algorithm=Config.ALGORITHM)
    # return {"access_token": encoded_jwt, "token_type": "bearer"}

    # Temporary return until JWT is implemented
    return {"message": f"Login successful for {user_credentials.username} (JWT placeholder)"}
